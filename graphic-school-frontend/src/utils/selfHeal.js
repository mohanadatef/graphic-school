/**
 * Self-Healing System for Graphic School
 * Automatically generates missing pages, translations, and tests
 */

import { writeFileSync, mkdirSync, existsSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Base paths
const PROJECT_ROOT = join(__dirname, '../..');
const LOGS_DIR = join(PROJECT_ROOT, 'self-heal-logs');
const AUTO_VIEWS_DIR = join(PROJECT_ROOT, 'src/views/auto-generated');
const AUTO_I18N_DIR = join(PROJECT_ROOT, 'src/i18n/auto');
const AUTO_TESTS_DIR = join(PROJECT_ROOT, 'cypress/e2e/auto');

// Ensure directories exist
function ensureDirectories() {
  [LOGS_DIR, AUTO_VIEWS_DIR, AUTO_I18N_DIR, AUTO_TESTS_DIR].forEach(dir => {
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
  });
}

ensureDirectories();

/**
 * Log self-healing actions
 */
export function logSelfHeal(action, details) {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    action,
    details,
  };
  
  const logFile = join(LOGS_DIR, `self-heal-${new Date().toISOString().split('T')[0]}.json`);
  
  let logs = [];
  if (existsSync(logFile)) {
    try {
      const content = readFileSync(logFile, 'utf-8');
      logs = JSON.parse(content);
    } catch (e) {
      logs = [];
    }
  }
  
  logs.push(logEntry);
  writeFileSync(logFile, JSON.stringify(logs, null, 2), 'utf-8');
  
  console.log(`[SELF-HEAL] ${action}:`, details);
}

/**
 * Generate a Vue page component
 */
export function generatePage(routePath) {
  const routeName = routePath
    .replace(/^\//, '')
    .replace(/\//g, '-')
    .replace(/[^a-z0-9-]/gi, '-')
    .toLowerCase();
  
  const fileName = `${routeName}.vue`;
  const filePath = join(AUTO_VIEWS_DIR, fileName);
  
  // Check if already exists
  if (existsSync(filePath)) {
    logSelfHeal('PAGE_EXISTS', { routePath, filePath });
    return filePath;
  }
  
  // Generate page template
  const componentName = routeName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
  
  const template = `<template>
  <div class="min-h-screen p-8">
    <div class="max-w-4xl mx-auto">
      <div class="bg-white dark:bg-slate-800 rounded-xl shadow-lg p-8">
        <div class="text-center mb-8">
          <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary/10 mb-4">
            <svg class="w-8 h-8 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
          </div>
          <h1 class="text-3xl font-bold text-slate-900 dark:text-white mb-2">
            {{ $t('auto.page.title', { route: '${routePath}' }) }}
          </h1>
          <p class="text-slate-600 dark:text-slate-400">
            {{ $t('auto.page.description', { route: '${routePath}' }) }}
          </p>
        </div>
        
        <div class="space-y-4">
          <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
            <p class="text-sm text-blue-800 dark:text-blue-200">
              <strong>{{ $t('auto.page.autoGenerated') }}</strong>
              {{ $t('auto.page.autoGeneratedDesc') }}
            </p>
          </div>
          
          <div class="prose dark:prose-invert max-w-none">
            <h2>{{ $t('auto.page.contentTitle') }}</h2>
            <p>{{ $t('auto.page.contentDescription') }}</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { useI18n } from '../../composables/useI18n';

const { t } = useI18n();
</script>

<style scoped>
/* Auto-generated page styles */
</style>
`;

  writeFileSync(filePath, template, 'utf-8');
  
  logSelfHeal('PAGE_GENERATED', {
    routePath,
    filePath: filePath.replace(PROJECT_ROOT, ''),
    componentName,
  });
  
  return filePath;
}

/**
 * Add missing translation keys
 */
export function addTranslation(locale, key, value = null) {
  const filePath = join(AUTO_I18N_DIR, `auto-${locale}.json`);
  
  let translations = {};
  if (existsSync(filePath)) {
    try {
      const content = readFileSync(filePath, 'utf-8');
      translations = JSON.parse(content);
    } catch (e) {
      translations = {};
    }
  }
  
  // Check if key already exists
  const keys = key.split('.');
  let current = translations;
  for (let i = 0; i < keys.length - 1; i++) {
    if (!current[keys[i]]) {
      current[keys[i]] = {};
    }
    current = current[keys[i]];
  }
  
  const lastKey = keys[keys.length - 1];
  if (current[lastKey]) {
    logSelfHeal('TRANSLATION_EXISTS', { locale, key });
    return;
  }
  
  // Generate default value if not provided
  if (!value) {
    value = key.split('.').pop().replace(/([A-Z])/g, ' $1').trim();
  }
  
  current[lastKey] = value;
  
  writeFileSync(filePath, JSON.stringify(translations, null, 2), 'utf-8');
  
  logSelfHeal('TRANSLATION_ADDED', {
    locale,
    key,
    value,
    filePath: filePath.replace(PROJECT_ROOT, ''),
  });
}

/**
 * Generate Cypress test for a route
 */
export function generateE2ETest(routePath) {
  const routeName = routePath
    .replace(/^\//, '')
    .replace(/\//g, '-')
    .replace(/[^a-z0-9-]/gi, '-')
    .toLowerCase();
  
  const fileName = `${routeName}.cy.js`;
  const filePath = join(AUTO_TESTS_DIR, fileName);
  
  // Check if already exists
  if (existsSync(filePath)) {
    logSelfHeal('TEST_EXISTS', { routePath, filePath });
    return filePath;
  }
  
  const testName = routePath
    .split('/')
    .filter(Boolean)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
  
  const testTemplate = `/**
 * Auto-generated E2E test for route: ${routePath}
 * Generated by Self-Healing System
 */

describe('Auto-Generated: ${testName}', () => {
  beforeEach(() => {
    cy.clearLocalStorage();
    cy.clearCookies();
  });

  it('Should load the page without errors', () => {
    cy.visit('${routePath}');
    cy.wait(2000);
    
    // Verify page loaded
    cy.get('body').should('be.visible');
    cy.get('body').should('not.be.empty');
    
    // Check for no console errors
    cy.window().then((win) => {
      // Log any console errors (non-blocking)
      if (win.console && win.console.error) {
        cy.log('Console errors checked');
      }
    });
    
    // Take screenshot
    cy.screenshot(\`auto-\${Date.now()}-${routeName}\`);
  });

  it('Should have basic page structure', () => {
    cy.visit('${routePath}');
    cy.wait(2000);
    
    // Check for main content
    cy.get('body').should('contain.text', '');
    
    // Verify no 404 errors
    cy.get('body').then(($body) => {
      const text = $body.text();
      expect(text.toLowerCase()).to.not.include('404');
      expect(text.toLowerCase()).to.not.include('not found');
      expect(text.toLowerCase()).to.not.include('page not found');
    });
  });
});
`;

  writeFileSync(filePath, testTemplate, 'utf-8');
  
  logSelfHeal('TEST_GENERATED', {
    routePath,
    filePath: filePath.replace(PROJECT_ROOT, ''),
  });
  
  return filePath;
}

/**
 * Add route to router
 */
export function addRouteToRouter(routePath, componentPath) {
  const routerPath = join(PROJECT_ROOT, 'src/router/index.js');
  
  if (!existsSync(routerPath)) {
    logSelfHeal('ROUTER_NOT_FOUND', { routerPath });
    return false;
  }
  
  let routerContent = readFileSync(routerPath, 'utf-8');
  
  // Check if route already exists
  if (routerContent.includes(`path: '${routePath}'`) || routerContent.includes(`path: "${routePath}"`)) {
    logSelfHeal('ROUTE_EXISTS', { routePath });
    return true;
  }
  
  // Generate route name
  const routeName = routePath
    .replace(/^\//, '')
    .replace(/\//g, '-')
    .replace(/[^a-z0-9-]/gi, '-')
    .toLowerCase();
  
  // Find the insertion point (before the closing bracket of routes array)
  const routeTemplate = `  {
    path: '${routePath}',
    name: 'auto-${routeName}',
    component: () => import('${componentPath.replace(PROJECT_ROOT, '').replace(/\\/g, '/')}'),
    meta: { middleware: [], autoGenerated: true },
  },
`;
  
  // Try to insert before the closing bracket of dashboardChildren or publicChildren
  const insertPattern = /(\];\s*\/\/\s*(?:Public|Dashboard)\s*routes)/;
  if (insertPattern.test(routerContent)) {
    routerContent = routerContent.replace(
      insertPattern,
      `${routeTemplate}$1`
    );
  } else {
    // Fallback: insert before the last closing bracket
    const lastBracket = routerContent.lastIndexOf('];');
    if (lastBracket !== -1) {
      routerContent = routerContent.slice(0, lastBracket) + 
        routeTemplate + 
        routerContent.slice(lastBracket);
    }
  }
  
  writeFileSync(routerPath, routerContent, 'utf-8');
  
  logSelfHeal('ROUTE_ADDED', {
    routePath,
    componentPath: componentPath.replace(PROJECT_ROOT, ''),
  });
  
  return true;
}

/**
 * Main self-healing handler for 404 routes
 */
export async function handle404Route(routePath) {
  try {
    logSelfHeal('404_DETECTED', { routePath });
    
    // Generate page
    const pagePath = generatePage(routePath);
    
    // Add route to router
    const relativePath = pagePath.replace(PROJECT_ROOT, '').replace(/\\/g, '/');
    addRouteToRouter(routePath, relativePath);
    
    // Generate E2E test
    generateE2ETest(routePath);
    
    // Add default translations
    addTranslation('en', `auto.page.title`, `Page: ${routePath}`);
    addTranslation('en', `auto.page.description`, `Auto-generated page for route: ${routePath}`);
    addTranslation('en', `auto.page.autoGenerated`, 'Auto-Generated Page');
    addTranslation('en', `auto.page.autoGeneratedDesc`, 'This page was automatically generated by the self-healing system.');
    addTranslation('en', `auto.page.contentTitle`, 'Content');
    addTranslation('en', `auto.page.contentDescription`, 'This page needs content. Please update it as needed.');
    
    addTranslation('ar', `auto.page.title`, `صفحة: ${routePath}`);
    addTranslation('ar', `auto.page.description`, `صفحة تم إنشاؤها تلقائياً للمسار: ${routePath}`);
    addTranslation('ar', `auto.page.autoGenerated`, 'صفحة تم إنشاؤها تلقائياً');
    addTranslation('ar', `auto.page.autoGeneratedDesc`, 'تم إنشاء هذه الصفحة تلقائياً بواسطة نظام الإصلاح الذاتي.');
    addTranslation('ar', `auto.page.contentTitle`, 'المحتوى');
    addTranslation('ar', `auto.page.contentDescription`, 'هذه الصفحة تحتاج إلى محتوى. يرجى تحديثها حسب الحاجة.');
    
    return true;
  } catch (error) {
    logSelfHeal('ERROR', {
      action: 'handle404Route',
      routePath,
      error: error.message,
    });
    return false;
  }
}

